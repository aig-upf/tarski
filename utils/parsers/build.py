#!/usr/bin/env python3
"""
Helper script to generate the parser from the ANTLR grammar.

Essentially this invokes ANTLR on the required grammars, performs a few name changes and moves the generated
files to the Tarski source tree. This should be invoked to generate the AST tree parser only when changes
to the grammar are performed.
"""

import argparse
import glob
import os
import shutil
import subprocess
import tempfile

GRAMMARS = {
    "fstrips": "fstrips.g4",
}

CURRENT_DIR = os.path.dirname(os.path.realpath(__file__))


def parse_arguments():
    parser = argparse.ArgumentParser(description="Build parser for one of the available grammars")
    parser.add_argument(
        "--grammar",
        default="fstrips",
        help="The grammar to generate. Currently accepted: {}".format(", ".join(GRAMMARS.keys())),
    )
    args = parser.parse_args()

    args.grammar_filename = os.path.join(CURRENT_DIR, "grammars", f"{args.grammar}.g4")
    if not os.path.exists(args.grammar_filename):
        raise RuntimeError(f"Could not find expected grammar file '{args.grammar_filename}'")

    return args


def main():
    args = parse_arguments()

    tmpdir = run_antlr(args)

    target = create_target_package(args)

    # The files generated by ANTLR will be left in /tmp/grammars/*
    prefix = args.grammar
    pattern = os.path.join(tmpdir.name, f"{prefix}*.py")
    print(f"ANTLR finished running. Generated parser files expected to be at: {pattern}")

    for name in glob.glob(pattern):
        process_antlr_file(name, prefix, target)


def process_antlr_file(name, prefix, target):
    target_filename = os.path.basename(name).replace(prefix, "").lower()
    dst = shutil.copy(name, os.path.join(target, target_filename))
    with open(dst) as instream:
        lines = instream.read()
    rules = [
        (f"from {prefix}Parser", "from parser"),
        (f"from .{prefix}Parser", "from .parser"),
        (f"from {prefix}Listener", "from listener"),
        (f"from .{prefix}Listener", "from .listener"),
        (f"from {prefix}Visitor", "from visitor"),
        (f"from .{prefix}Visitor", "from .visitor"),
        (f"from {prefix}Lexer", "from lexer"),
        (f"from .{prefix}Lexer", "from .lexer"),
    ]
    for old, new in rules:
        lines = lines.replace(old, new)
    with open(dst, "w") as outstream:
        outstream.write(lines)
    print(f"Generated and processed file '{dst}'")


def create_target_package(args):
    # This path is likely to require manual adjustments, but no need to worry too much about this
    source_tree = os.path.realpath(os.path.join(CURRENT_DIR, "..", "..", "src", "tarski", "io"))
    target = os.path.join(source_tree, f"_{args.grammar}", "parser")
    os.makedirs(target, exist_ok=True)
    open(os.path.join(target, "__init__.py"), "a").close()  # i.e. create the __init__.py file
    print(f"Created parser module at '{target}'")
    return target


def run_antlr(args):
    tmpdir = tempfile.TemporaryDirectory()
    antlr_path = os.getenv("ANTLR_PATH")
    if antlr_path is None:
        raise RuntimeError("Please set 'ANTLR_PATH' to the location of the ANTLR jar file")

    command = f"java -cp {antlr_path} -Xmx500M org.antlr.v4.Tool -visitor -Dlanguage=Python3 -o {tmpdir.name} {args.grammar_filename}"

    try:
        print(f"Executing: {command}")
        subprocess.check_output(command, shell=True)
    except Exception:
        raise RuntimeError(
            "Could not execute ANTLR. Make sure it is correctly installed and the environment variable "
            f"'ANTLR_PATH' points at the ANTLR jar file. Command:\n{command}"
        ) from None
    return tmpdir


if __name__ == "__main__":
    main()
